module AP.UI.Component.HomeCopy where

import Prelude

-- import AP.Capability.ApiClient (class MonadApiClient, Ledger, createLedger, getLedgers)
-- import AP.UI.Capability.Navigate (class MonadNavigate, navigate)
-- import AP.UI.Component.HTML.Utils (css)
-- import AP.UI.Component.Ledger.CreateLedger as CreateLedger
-- import AP.UI.Form.Validation as V
-- import AP.UI.Part.Button (btnSubmit_, linkBtn_)
-- import AP.UI.Part.Form (inputText_)
-- import AP.UI.Route as Routes
-- import AP.UI.Store as Store
-- import Data.Const (Const)
-- import Data.Either (Either(..))
-- import Data.Maybe (Maybe(..))
-- import Effect.Aff.Class (class MonadAff)
-- import Formless as F
-- import Halogen as H
-- import Halogen.HTML as HH
-- import Halogen.HTML.Events as HE
-- import Halogen.HTML.Properties as HP
-- import Halogen.Store.Connect (Connected, connect)
-- import Halogen.Store.Monad (class MonadStore)
-- import Halogen.Store.Select (selectAll)
-- import Type.Proxy (Proxy(..))

-- type Input = Unit
-- type Output = Unit
-- type Query :: forall k. k -> Type
-- type Query = Const Void

-- data State
--   = Loading
--   | Loaded
--     { ledgers :: Array Ledger
--     , showNewLedger :: Boolean
--     }

-- data Action
--   = Initialize
--   | OpenLedger String
--   | CreateNewLedgerResult CreateLedger.Output
--   | StartNewLedger
--   | CancelNewLedger

-- type ChildSlots =
--   ( createLedger :: H.Slot (Const Void) CreateLedger.Output Unit
--   )

-- homeComponent
--   :: forall m
--    . MonadApiClient m
--   => MonadStore Store.Action Store.Store m
--   => MonadAff m
--   => MonadNavigate Routes.Route m
--   => H.Component Query Input Output m
-- homeComponent = connect selectAll $ H.mkComponent
--     { initialState: const Loading
--     , render
--     , eval: H.mkEval H.defaultEval
--         { initialize = Just Initialize
--         , handleAction = handleAction
--         }
--     }
--   where
--   handleAction :: Action -> H.HalogenM State Action ChildSlots Output m Unit
--   handleAction = case _ of
--     Initialize -> do
--       -- refresh ledger list?
--       pure unit
--     OpenLedger ledgerId -> do
--       navigate $ Routes.Ledger ledgerId Routes.LedgerDashboard
--     StartNewLedger -> H.modify_ case _ of
--       Loaded x -> Loaded x { showNewLedger = true }
--       x -> x
--     CancelNewLedger -> H.modify_ case _ of
--       Loaded x -> Loaded x { showNewLedger = false }
--       x -> x
--     CreateNewLedgerResult (CreateLedger.LedgerCreationRequested name) -> do
--       createLedger name
--       handleAction Initialize
--     CreateNewLedgerResult (CreateLedger.LedgerCreationCancelled) -> do
--       handleAction CancelNewLedger
--   render :: State -> H.ComponentHTML Action ChildSlots m
--   render state =
--     HH.div
--       [ css "text-center min-h-screen w-screen flex flex-col justify-center items-center" ]
--       [ HH.div
--         [ css "max-w-screen-lg p-4"]
--         [ HH.h1
--             [ css "text-4xl text-center w-full" ]
--             [ HH.text "Empire Builder" ]
--         , HH.h2
--             [ css "mb-12 text-gray-400" ]
--             [ HH.text "Pick a Ledger" ]
--         , case state of
--           Loading -> renderLoading
--           Loaded x -> renderLoaded x
--         ]
--       ]
--   renderLoading =
--     HH.div_ [ HH.text "Loading..."]
--   renderLoaded { ledgers, showNewLedger } =
--     HH.ul [ css "flex flex-col gap-2" ] $
--       [ HH.li_
--         if showNewLedger
--         then
--           [ HH.slot (Proxy :: _ "createLedger") unit CreateLedger.createLedgerComponent unit CreateNewLedgerResult
--           ]
--         else
--           [ linkBtn_ "New Ledger" StartNewLedger
--           ]
--       ]
--       <>
--       ( ledgers <#> \ledger ->
--         HH.li_
--           [ linkBtn_ ledger.result.name $ OpenLedger ledger.ledgerId ]
--       )